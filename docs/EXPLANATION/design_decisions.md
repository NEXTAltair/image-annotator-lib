# 解説: 設計決定の背景

このドキュメントでは、`image-annotator-lib` の開発過程における重要な技術的課題、採用された解決策、および主要な設計決定の背景について解説します。

## 統合における技術的課題と解決策

`scorer_wrapper_lib` と `tagger_wrapper_lib` の統合にあたり、以下の主要な課題に直面し、解決策を講じました。

1.  **クラス設計の重複と相違**

    - **課題:** 両ライブラリは類似の機能（モデル管理、予測実行）を持ちつつも、クラス構造や実装アプローチが異なり、重複も存在しました。
    - **解決策:** [アーキテクチャ](./architecture.md) で詳述する **3 層構造のクラス階層** (`BaseAnnotator` -> フレームワーク基底 -> 具象クラス) を採用し、責務を明確に分離しました。フレームワーク非依存の共通処理、フレームワーク固有の共通処理、モデル固有の処理をそれぞれ適切な層に配置しました。
    - **選択理由:** コードの重複を最小化し、単一継承の原則を維持しながら、拡張性と保守性を高めるため。

2.  **実装方針の競合**

    - **課題:** 実装方法や命名規則 (特にバッチ処理関連) に相違があり、どちらを採用するかの基準が必要でした。
    - **解決策:** 原則として、より新しく設計が改善されていた `tagger_wrapper_lib` の実装や命名規則を優先するルールを設定しました。ただし、スコアリング固有の機能は `scorer_wrapper_lib` の実装を尊重し、コード品質が明らかに高い場合は個別判断としました。
    - **選択理由:** 明確な優先順位を設けることで、統合プロセスにおける意思決定を迅速化し、一貫性を確保するため。

3.  **バッチ処理方式の不統一**

    - **課題:** `tagger_wrapper_lib` はバッチ処理に対応していましたが、`scorer_wrapper_lib` は単一画像処理が基本でした。
    - **解決策:** `BaseAnnotator.predict()` 内で **チャンク処理** を標準実装しました。サブクラス (フレームワーク基底クラスや具象クラス) は、バッチ形式のデータを処理するヘルパーメソッド (`_preprocess_images`, `_run_inference` など) を実装する方式に統一しました。
    - **選択理由:** メモリ効率 (特に OOM エラー対策) と処理速度の両方を考慮し、統一的なインターフェースを提供するため。

4.  **型安全性と静的解析**

    - **課題:** 元のコードでは型ヒントが不十分で、実行時エラーのリスクがありました。API の戻り値構造も曖昧でした。
    - **解決策:**
      - **TypedDict (`AnnotationResult`)** を導入し、ライブラリ内部および `annotate` 関数の戻り値に含まれる結果辞書の構造を明確に定義しました ([API リファレンス](../REFERENCE/api.md) 参照)。
      - 型ヒントを徹底し、Mypy による静的型チェックを活用しました。
      - **Mypy の戻り値キャストに関する注意:** Mypy が戻り値のキャストを要求するメッセージを出す場合がありますが、これは Mypy の解析が完了していない段階で発生することがあります。解析が完了すれば不要になるケースが多いため、安易にキャストを追加せず、まずは解析完了を待つか、他の型定義の問題がないか確認してください。
    - **選択理由:** API の一貫性とコード品質を向上させ、開発時のエラー検出を容易にするため。

5.  **メモリ管理 (CUDA OOM 対策)**

    - **課題:** 大規模なモデルを使用する際に GPU メモリ不足 (OOM) が発生しやすい問題がありました。
    - **解決策:** `ModelLoad` (`core/model_factory.py`) におけるキャッシュ管理を強化しました。
      - LRU (Least Recently Used) に基づくキャッシュ解放戦略。
      - メモリ状況に応じたデバイス間移動 (CUDA -> CPU -> CUDA) の標準化。
      - `BaseAnnotator` でのチャンク処理実装。
    - **選択理由:** モデル利用の安定性を高め、限られたリソースを効率的に活用するため。

6.  **結果生成メソッドの命名と責務 (修正)**

    - **課題:** 開発中に `_generate_tags` と `_generate_result` という類似した目的のメソッドが存在し、当初のドキュメントで責務の記述に誤りがありました。
    - **解決策と責務:**
      - **`_generate_tags(self, formatted_output: Any) -> list[str]`**: これは **抽象メソッド** であり、サブクラス (主に具象モデルクラス、または必要に応じてフレームワーク基底クラス) での実装が **必須** です。責務は、`_format_predictions` で整形されたモデル固有の出力 (`formatted_output`) を受け取り、最終的なタグ情報 (タグ、スコアタグ、キャプションなど) を **文字列のリスト (`list[str]`)** として生成することです。
      - **`_generate_result(self, *, phash: str | None, model_name: str, tags: list[str], formatted_output: Any, error: str | None) -> AnnotationResult`**: これは `BaseAnnotator` で実装されている **非抽象メソッド** です。責務は、`predict` メソッド内で計算・生成された各要素 (`phash`, `model_name`, `tags` (これは `_generate_tags` の結果), `formatted_output`, `error`) を受け取り、標準化された内部結果構造である **`AnnotationResult` TypedDict** を作成することです。サブクラスはこのメソッドを通常オーバーライドする必要はありません (オーバーライド非推奨)。
    - **選択理由:** 各メソッドの責務を明確に分離し、`_generate_tags` でモデル固有のタグ生成ロジックに集中させ、`_generate_result` で結果構造の統一性を `BaseAnnotator` が保証するようにしました。これにより、サブクラスの実装が簡素化され、一貫性が保たれます。

7.  **画像と結果の紐付け**
    - **課題:** 従来のインデックスベースの管理では、バッチ処理の順序変更やエラー発生時に、入力画像と出力結果の対応関係を確実に維持するのが困難でした。
    - **解決策:** **画像の知覚ハッシュ (pHash)** を計算し、`annotate` 関数の戻り値のトップレベルキーとして使用する方式を採用しました。pHash 計算失敗時には代替キー (`unknown_image_{index}`) を使用します。
    - **選択理由:** 処理順序やエラーに依存しない、堅牢な画像と結果の紐付けを実現するため。また、同一画像の重複処理検出や、将来的な類似画像検索などの機能拡張の基盤となるため。
    - **具体的実装:** `BaseAnnotator._calculate_phash()` メソッドと、`AnnotationResult` TypedDict への `phash` フィールド追加 (ただし `annotate` 関数の戻り値では `phash` はキーとして使われる)。

## その他の重要な設計決定

- **コンテキストマネージャ (`with` 文) の採用:**

  - モデルのロード・アンロード (キャッシュへの退避含む) を `__enter__` と `__exit__` で管理します。
  - PyTorch など他のライブラリのリソース管理パターンに合わせ、`with` 構文による安全なリソース管理を基本としました。これにより、メモリリークのリスクを低減します。

- **統一された例外階層:**

  - `AnnotatorError` (`exceptions/errors.py`) を基底クラスとする一貫した例外階層を設計しました。
  - `ModelNotFoundError`, `ModelLoadError`, `OutOfMemoryError` など、具体的なエラー状況を示す例外クラスを用意し、エラーハンドリングとデバッグを容易にしました。

- **共通実装の優先:**

  - バッチ (チャンク) 処理、基本的なエラーハンドリング、結果構造の生成 (`_generate_result`) など、モデルやフレームワークに依存しない共通処理は、可能な限り最上位の `BaseAnnotator` に実装しました。
  - これにより、サブクラスでの実装量を減らし、ライブラリ全体の一貫性を確保しました。

- **API アーキテクチャ:**
  - **`annotate` 関数 (`api.py`):** ユーザー向けの主要なエントリーポイントとして提供されます。内部で `ModelRegistry`, `ModelLoad`, 各 `BaseAnnotator` サブクラスなどを協調させて呼び出し、複数モデル・複数画像の一括処理と pHash ベースの結果集約を行います。既存のテストコードとの互換性も考慮されています。当初検討されていた `Annotator` クラスによるコンテキストマネージャ形式のインターフェースは採用しないことになりました。