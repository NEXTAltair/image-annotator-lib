---
description: Always attach when Implementing Code (Act/Code MODE)
globs:
alwaysApply: false
---
---
description: Include these rules while IMPLEMENTATION/Coding.
globs:
alwaysApply: true
---
コードの実装や変更の前に**必ず**2つのことを行うこと:
a. `docs/` と `tasks/` 内のドキュメントを読み理解する。
a. `src` など他のコードから必要なコードコンテキストを取得する。
---
# 実装 (ACTモード/Codeモード):
<PROGRAMMING PRINCIPLES>
- algorithm_efficiency(アルゴリズム効率): 最も効率的なアルゴリズムとデータ構造を使用する。
- modularity(モジュール化): 複雑なロジックは小さな単位に分割する。可能ならクラス、ファイル、ディレクトリ、モジュール、関数などへ分ける。
- file_management(ファイル管理): 長大なファイルは、より小さく管理しやすいファイルに分割する。
- import_statements(インポート方針): 直接ファイルを修正するのではなく、他ファイルから関数をインポートして使用する。
- file_organization(ファイル整理): ファイルをディレクトリ･フォルダ単位で整理する。
- reuse(再利用): 既存コードを優先的に再利用し、新たに書くのは最小限にする。
- code_preservation(動作コードの保護): 正常動作しているコンポーネントは必要がなければ変更しない。
- systematic_sequence(系統的手順): 1ステップを完全に終わらせてから次に進む。
- design_patterns(設計パターン): 将来変更や拡張しやすい柔軟かつ保守性の高いコード設計を行う。
- proactive_testing(積極的テスト): すべての機能コードには必ず適切なテストコードを併設する。
</PROGRAMMING PRINCIPLES>

<SYSTEMATIC CODE PROTOCOL>
[ステップ1]
<ANALYZE CODE>
<DEPENDENCY ANALYSIS>
- どのコンポーネントが影響を受けるか?
- どんな依存関係が存在するか?
- 影響はローカルか、コアロジックに及ぶか?
- どの機能がどう影響を受けるか?
- この変更による波及効果は?
</DEPENDENCY ANALYSIS>
<FLOW ANALYSIS>
- 変更提案前に、関連ユースケースを**エントリーポイント(関数呼び出し、変数初期化など)からすべての影響範囲まで**完全に分析する。
- データとロジックの流れをすべて追跡して、全体像を理解する。
</FLOW ANALYSIS>
- @memory.mdcに記載されたファイルにおける依存関係や使用状況も正確に記録する。
</ANALYZE CODE>

[ステップ2]
<PLAN CODE>
- 必要であれば<CLARIFICATION>プロセスを開始する。
- <STEP BY STEP REASONING>を使って詳細計画を立てる(コンポーネント依存、アーキテクチャ考慮)。
- <REASONING PRESENTATION>で、コード変更の目的、各変更箇所、他への影響を説明する。
<STRUCTURED PROPOSALS>
- 以下を明確に示す提案を作成する:
  1) 変更対象のファイル、関数、コード行
  2) 変更理由(バグ修正、改善、新機能)
  3) 直接影響を受けるモジュール･ファイル
  4) 副作用の可能性
  5) トレードオフの詳細な説明
</STRUCTURED PROPOSALS>
</PLAN CODE>

[ステップ3]
<MAKE CHANGES>

1. @memory.mdcに従い、現在の状態を記録する。
- どこが正常動作しているか
- 現在のエラー/問題点
- 影響を受けるファイル

2. 単一の論理的変更ごとに計画する。
<INCREMENTAL ROLLOUTS>
- 一度に1つの論理的機能だけ変更する。
- 関連コードすべてに適切な調整を加える。
- 依存関係や派生する問題も全て解決する。
- architecture_preservation(アーキテクチャ維持): 既存構造に沿ってコードを統合する。既存ファイル構成を壊さない。
</INCREMENTAL ROLLOUTS>

3. シミュレーションテストを実施。
<SIMULATION ANALYSIS>
- ユーザー操作や挙動をシミュレートし、変更が想定通り動作するか、すべての影響範囲を確認する。
</SIMULATION ANALYSIS>
<SIMULATION VALIDATION>
- シミュレーションが通らなければ、修正を加えてから次に進む。
- シミュレーション合格後に実装を開始する。
</SIMULATION VALIDATION>
</MAKE CHANGES>

[ステップ4] <TESTING>を実行。

[ステップ5] 1~4を繰り返してすべての変更を実施。
- すべて系統立てて変更。
- 1つずつ検証･テスト。

[ステップ6] 実装後に最適化。
- テスト･検証後にコードを最適化する。

</SYSTEMATIC CODE PROTOCOL>

<REFERENCE>
- 関連ドキュメントやベストプラクティスを参照する。
- 必要なら<WEB USE>を使って調査する。
</REFERENCE>

# コーディングルール詳細 (AI向け指示)

## 開発環境
- **OS:** Windows 11 を開発環境として想定する。
- **Python:** Python 3.12 を使用する。
- **依存関係管理:** 開発環境の依存関係管理には `uv` を使用する。

## コーディングスタイル
- **PEP 8:** PEP 8 ガイドラインに従うこと。
- **命名規則:**
    - 変数名、関数名、メソッド名は、その役割や意味が明確にわかる具体的な名前 (`snake_case`) を使用する。
    - クラス名は、その役割や特性を具体的に表す名詞または名詞句 (`CamelCase`) とする。**安易に動詞に `er` を付けただけの名前(例: `Loader`, `Runner`)は避け、より具体的な名前(例: `ModelLoad`, `InferenceRun`)を選ぶこと。**
- **パス処理:** パス操作には `os` モジュールではなく `pathlib` モジュールを使用する。
- **リスト内包表記:** 可読性を維持するため、リスト内包表記内での `if` と `for` の使用はそれぞれ1つまでに制限する。

## 型ヒントと静的解析
- **型ヒント:**
    - すべての関数、メソッドの引数と戻り値には、可能な限り具体的な型ヒントを付与する。
    - **モダンな型:** `typing.List` や `typing.Dict` ではなく、Python 3.9 以降の組み込み型 (`list`, `dict`) や `collections.abc` の型を使用する。Optional型も使用せず `str | None`と表記する。
    - **複雑な型:** 複雑な辞書構造には `TypedDict` を活用する。
    - **オーバライド:** 親メソッドをオーバーライドしたメソッドは `@override`デコレーターを使用しオーバーライドしてあると明示する。
    - **メソッドチェーン:** メソッドチェーンを考慮する場合は `Self` 型を使用する。
    - **`Any` の回避:** `Any` 型の使用は最小限に留め、具体的な型を指定するよう努めること。やむを得ず使用する場合は理由をコメントに残すこと。
- **静的解析:**
    - **エラー抑制禁止:** Mypy や Ruff (lint) が報告するエラーや警告は、`# type: ignore` や `# noqa` コメントで抑制せず、コードや型定義を修正して根本的に解決する。
    - **回避策禁止:** **`try...except ImportError` などで Mypy エラーを回避するような、その場しのぎの対応も禁止する。**

## エラーハンドリング
- **特定のエラー処理:** 予期される特定のエラー(例: `FileNotFoundError`, `ValueError`, `KeyError`, `OutOfMemoryError`)のみを具体的に `try...except` で捕捉し、適切に処理する。
- **過剰なハンドリング回避:** 予期しない一般的な `Exception` を広範囲にキャッチして処理を継続するような、過剰なエラーハンドリングは避けること。不明なエラーはログに記録し、適切に上位に伝播させるか、処理を中断する。
- **無意味なハンドリング回避:** 前段の処理で既にエラーが発生している可能性がある場合、後続の処理で無意味なエラーハンドリング(例: 失敗した可能性のある変数をさらに `try...except` で囲む)を行わないこと。エラー発生時の制御フローを明確に設計する。
- **`OutOfMemoryError`:** メモリ不足エラーは適切にキャッチし、発生箇所(モデル名、デバイスなど)がわかる情報を含めて再送出する。
- **エラーメッセージ:** エラー発生時は、原因特定に役立つ明確なエラーメッセージを含めること。

## 設計原則
- **単一責任の原則 (SRP):** 各クラス、関数、モジュールは、単一の明確な責任を持つように設計する。
- **責任分離:** 状態管理や特定の複雑な処理は、専用のクラスや関数に委譲するを検討する。
- **カプセル化:** クラスの内部実装への依存を避け、公開インターフェースを通じてのみ対話する。

## カプセル化ルール (AI向け指示)
- **最重要禁止事項:**
    - **他クラス内部変数への直接アクセス禁止:** 他クラスの内部変数 (`_` 始まり) には**絶対にアクセスしないこと**。これはカプセル化を破壊し、保守性を著しく低下させる。
- **クラス設計原則:**
    - **Tell, Don't Ask:** クラス利用者は内部状態を知る必要がないように設計すること。状態を問い合わせて外部で判断するのではなく、必要な操作や判断はクラス自身の**振る舞い (メソッド)** として提供すること。
    - **内部状態の非公開:**
        - 内部状態は原則として外部に公開しない。
        - 状態の公開が必要な場合(読み取り専用)は `@property` を使用し、**ミュータブルな内部オブジェクト (`list`, `dict` 等) の参照を直接返さないこと** (防御的コピーも原則禁止)。必要最小限の情報をイミュータブルな形式で返すことを検討すること。
        - 状態変更は、その操作がクラスの責務として意味を持つ公開メソッド経由でのみ行うこと。
    - **ゲッター/セッター原則禁止:** 単純な値取得 (`get_*`) や設定 (`set_*`) のためだけのメソッドは**作成しないこと**。
    - **公開インターフェース最小化:** 外部に公開するメソッドやプロパティは、クラスの責務遂行に**必要最小限**とすること (YAGNI原則)。
    - **命名:** 内部変数は `_` プレフィックスを付与し、公開メンバーは役割が明確な名前とすること。
- **リファクタリング方針:**
    - 既存コードの違反は以下の優先度で修正すること。
        1.  **最高:** 他クラス内部変数への直接アクセス。
        2.  **高:** 他クラス内部メソッド (`_`始まり) への直接アクセス。
        3.  **中:** 安易なゲッター/セッター、ミュータブルな内部参照の返却。
- **チェックリスト (AI向け):**
    - [ ] 他クラス内部変数 (`_`始まり) への直接アクセスはないか?
    - [ ] 内部状態を不必要に公開していないか? (安易なゲッター/セッター、ミュータブル参照返却はないか?)
    - [ ] 公開インターフェースは最小限か?
    - [ ] 命名規則は守られているか?

## 原則違反の通知
- **ユーザーへの通知:** AI がこれらの定義された原則に違反するコードを生成･編集せざるを得ない場合は、**一度作業を停止し、必ずユーザーにその旨と理由を説明し、指示を仰ぐこと。**

## 問題解決プロセス
- **エラー/警告対応:** エラーや警告が発生した場合、AI は以下の手順で対応する。
    1.  **解決策の検討:** 問題の原因を分析し、少なくとも3つ以上の異なる解決策を検討する。
    2.  **最適な解決策の選択:** 検討した解決策の中から、最も適切と考えられるものを選択し、その理由を記録する。
    3.  **試行と反復:** 選択した解決策を適用し、問題が解決したか確認する。解決しない場合は、別の解決策を試すか、さらに別の解決策を検討する。
    4.  **エスカレーション:** 上記の試行を3回以上繰り返しても問題が解決しない場合は、作業を中断し、ユーザーに現在の状況、試した解決策、および考えられる原因を説明し、判断を求めること。

## 自己チェック義務
AI はコードを生成･編集した後、ユーザーに提示する前に**必ず**以下の点について自己チェックを行い、ルール違反があれば修正すること。
- [ ] **半角文字:** コード、コメント、ドキュメント内に全角英数字･全角記号が含まれていないか? (特に括弧、スペース)
- [ ] **モダンな型ヒント:** `typing.List`, `typing.Dict`, `typing.Optional` など古い型を使用していないか? (`list`, `dict`, `| None` を使用しているか?)

# ドキュメンテーションルール (実装時)
- **Docstring:** 各関数･メソッドには Google スタイル docstring **追加すること**。最低限、「Args:」「Returns:」セクション含め、必要応じ「Raises:」セクションも記述すること。
- **モジュールコメント:** 各モジュール冒頭に、そのモジュール目的、主要クラス･関数、外部依存関係等簡潔説明コメント**追加すること**。
- **実装コメント:** 実装意図説明する簡潔明確日本語コメント**記述すること**。
- **コードアノテーション:** コード新規作成または**変更**時、必要応じ Todo Tree 拡張タグ (`TODO`, `FIXME`, `OPTIMIZE` 等) 用いたコメントアノテーション**必ず**追加･更新し、変更意図、将来改善点、修正必要箇所、残課題等明確にすること。使用タグは以下基本とする:
    - `TODO`: 将来実装予定機能･改善点
    - `FIXME`: 修正必要既知問題
    - `OPTIMIZE`: 最適化必要部分
    - `BUG`: 確認済バグ
    - `HACK`: 一時回避策･最適でない実装
    - `XXX`: 特別注意･再考必要箇所
    - `[ ]`: 未完了タスク
    - `[x]`: 完了タスク

# image-annotator-lib 内部実装ルール･設計概要 (AI 向け指示)
## 1. 内部実装ルール (AI 向け指示)
### 1.1. クラス責務
AI は `image-annotator-lib` の内部クラスを実装･変更する際、以下の責務分担に従うこと。
- **`BaseAnnotator` (`core/base.py`)**:
  - すべてのアノテーターの共通インターフェース(抽象メソッド)を定義すること。
  - 共通の `predict()` メソッド(チャンク処理、エラーハンドリング含む)を実装すること。
  - 標準化された結果 (`AnnotationResult`) を生成する `_generate_result()` メソッドを提供すること。
- **フレームワーク別基底クラス (`core/base.py` 内、例: `TransformersBaseAnnotator`)**:
  - フレームワーク固有の初期化処理 (`__init__`)、リソース管理 (`__enter__`, `__exit__`) を実装すること。
  - フレームワーク固有の画像前処理 (`_preprocess_images`)、推論実行 (`_run_inference`)、出力フォーマット (`_format_predictions`) の**デフォルト実装**を提供すること。
- **具象モデルクラス (`models/` 配下)**:
  - モデル固有の初期化(設定読み込み、タグ/ラベルロードなど)を行うこと。
  - フレームワーク別基底クラスのメソッドを必要に応じてオーバーライドし、モデル固有の処理(特に `_generate_tags`)を実装すること。
- **`ModelLoad` (`core/model_factory.py`)**:
  - 各フレームワークに対応したモデルのロード、キャッシュ管理(LRU、CPU 退避)、メモリ使用量推定、リソース解放の責務を担うこと。
- **`core/registry.py` モジュール**:
  - モジュールレベルの関数と辞書を用いて、`models/` ディレクトリ内の具象モデルクラスを動的に検出し、設定ファイル に基づいてモデル名とクラスを紐付けて登録する責務を担うこと。
### 1.2. オーバーライドルール
- **禁止:**
  - `BaseAnnotator.predict()`: 共通実装を使用し、**絶対にオーバーライドしないこと**。(.clinerules も参照)
  - `BaseAnnotator._generate_result()`: 標準の結果生成処理を使用し、**オーバーライドしないこと**。
- **必須:**
  - `_preprocess_images()`: フレームワーク別基底クラスまたは具象モデルクラスで**必ず実装すること**。
  - `_run_inference()`: フレームワーク別基底クラスまたは具象モデルクラスで**必ず実装すること**。
  - `_format_predictions()`: フレームワーク別基底クラスまたは具象モデルクラスで**必ず実装すること**。
  - `_generate_tags()`: 具象モデルクラスで**必ず実装すること**。
- **推奨:**
  - `__enter__()`, `__exit__()`: フレームワーク別基底クラスで実装することを推奨する。
### 1.3. 参照
- クラス間のアクセス制御(カプセル化)については を参照すること。
## 2. 設計概要と変更のポイント
### 2.1. 目的
- コードの重複削減、API の統一、メンテナンス性の向上、機能拡張の容易化を図ること。特にモデル管理 (`ModelLoad`) とクラス登録 (`registry.py`) の共通化を重視すること。
### 2.2. 主要な機能
- 画像タギング､キャプショニング､スコアリング機能 (Annotator)
- 設定ファイル [annotator_config.toml](mdc:src/image_annotator_lib/resources/system/annotator_config.toml) 駆動のモデル選択･設定。
- 統一された高機能モデル管理 (動的登録、メモリ管理、エラーハンドリング)。
- 統一された API インターフェース (`Annotator` クラス経由、または直接モデルクラス利用)。
### 2.3. 統合による主な変更点と理由
- **`BaseAnnotator` への統一:**
  - **変更:** Tagger と Scorer の基底クラスを `BaseAnnotator` に統一した。
  - **理由:** 異なる種類のアノテーターを共通のインターフェースで扱えるようにし、ポリモーフィズムを実現するため。共通処理を集約しやすくするため。
- **`predict` メソッドの共通化:**
  - **変更:** 予測処理のメインロジック(チャンク分割、エラーハンドリング)を `BaseAnnotator.predict()` に実装し、サブクラスでのオーバーライドを禁止した。サブクラスはコア処理(前処理、推論、フォーマット、タグ生成)の抽象メソッド実装に集中する。
  - **理由:** 冗長な実装を排除し、エラーハンドリングやバッチ処理のロジックを一元化するため。サブクラスの実装を簡略化するため。
- **`ModelLoad` の導入･強化:**
  - **変更:** モデルのロード、キャッシュ管理(LRU、CPU 退避)、メモリ使用量推定、リソース解放の責務を `ModelLoad` クラス (`core/model_factory.py`) に集約した。フレームワークごとのローダークラスを内部で使用する構造に変更した。
  - **理由:** リソース管理ロジックをアノテータークラスから分離し、責務を明確にするため。より高度で一貫性のあるメモリ管理を実現するため。
- **`registry.py` モジュールの導入:**
  - **変更:** `models/` ディレクトリ内のモデルクラスを動的に検出し、設定ファイルに基づいて登録する機能を `core/registry.py` モジュールとして実装した。
  - **理由:** モデルクラスの追加･変更時にコードの修正を不要にし、拡張性を高めるため。設定ファイル駆動の柔軟なモデル管理を実現するため。
- **`AnnotationResult` への統一:**
  - **変更:** `predict()` の戻り値形式を `list[AnnotationResult]` TypedDict に統一した。
  - **理由:** ライブラリの出力形式を標準化し、利用側での処理を容易にするため。エラー情報なども含められるようにするため。
## 3. 補足情報 (参考)
### 3.2. 主要クラス/モジュール
- **`Annotator` (`annotator.py`)**: ユーザー向け統合 API。
- **`BaseAnnotator` (`core/base.py`)**: 共通抽象基底クラス。
- **`ModelLoad` (`core/model_factory.py`)**: モデルロード/キャッシュ管理。
- **`core/registry.py`**: モデルクラス登録モジュール。
- **`core/config.py`**: 設定管理クラス `ModelConfigRegistry` (設定ファイル全体の読み込み･保持、設定値へのアクセス提供) と共有インスタンス `config_registry`、関連定数を定義。
- **`core/utils.py`**: ロギング設定 (`setup_logger`) および汎用ユーティリティ (ファイルI/O、ネットワーク、画像処理など)。
- **各種 Tagger/Scorer 実装クラス (`models/`)**: `BaseAnnotator` 継承クラス。
- **共通例外クラス (`exceptions/errors.py`)**: `AnnotatorError` など。
### 3.3. コーディング規約/開発環境 (主要ツール)
(詳細は [coding-rules.mdc](mdc:.cursor/rules/coding-rules.mdc) を参照)

# テスト方針
## 基本方針
- 各機能にはテストを作成し、十分なテストカバレッジを確保する。
- ステップ記述(Step description)は日本語で記述する。
## BDD (振る舞い駆動開発) の基本
- **Feature**:
  - テスト対象となる機能やユーザーストーリーを記述する。
  - ユーザー視点での価値や目的を明確にすることが重要である。
  - 具体的な関数名、メソッド名、ファイル名、Pathなどは含めないこと。
- **Scenario**:
  - Feature 内の具体的な振る舞いを検証する個別のテストケースである。
  - 一つのシナリオでは、一つの振る舞いに焦点を当てる。
- **Given / When / Then**:
  - **Given**: テスト実行前のシステムの初期状態や前提条件を設定する。
  - **When**: ユーザーの操作や、システムに対する特定のアクションを記述する。
  - **Then**: When のアクションによって期待される結果やシステムの応答を検証する。
  - Given-When-Then 形式で機能を明確に記述する。
## 異常系テスト
- **基本的な考え方**: 主要な正常系のパスがある程度確認できた段階で、代表的な異常系(エラーハンドリング、不正な入力、境界値など)のシナリオも計画･実装することを推奨する。
- **デバッグ時の活用**: 正常系のテストが失敗した場合、その原因究明や特定の失敗パターンを再現するために、追加で異常系のシナリオを作成するアプローチも有効である。
- **目的**: 異常系テストは、システムが予期せぬ状況下でも安全に動作(クラッシュしない、意図しない挙動をしない、適切なエラーを示すなど)することを確認するために重要である。
## テストの執行
- `uv run pytest` コマンドで実行する。
- コマンドオプションは必要に応じて使い分ける。
- カバレッジの測定結果は `XML` として出力する。

# BDD Feature ファイル ルールガイドライン
## 1. Feature ファイルの基本構造
- **配置**: Feature ファイルは `tests/features` ディレクトリに配置する。
- **Feature 説明**: ファイルの冒頭で、Feature 全体の目的や背景を簡潔に説明する。ユーザー視点の価値を明確にする。
- **Background**:
  - 複数のシナリオで共通となる前提条件(主に Given ステップだが、状況に応じて When/Then も含む共通手順)を記述する。
  - これにより、各シナリオでの記述の重複を避け、コードを圧縮する。
- **Scenario**:
  - Feature 内の具体的な振る舞いを検証する個別のテストケース。
  - 一つのシナリオでは、一つの振る舞いに焦点を当てる。
- **Given / When / Then**:
  - **Given**: テスト実行前のシステムの初期状態や前提条件を設定する。
  - **When**: ユーザーの操作や、システムに対する特定のアクションを記述する。
  - **Then**: When のアクションによって期待される結果やシステムの応答を検証する。
  - Given-When-Then 形式で機能を明確に記述する。
## 2. シナリオ記述のベストプラクティス
- **明確な自然言語**:
  - 開発者だけでなく、ビジネス担当者など非エンジニアにも理解できる平易な言葉を選ぶ。
  - 専門用語や実装の詳細(具体的な関数名、メソッド名、ファイル名、Pathなど)に寄りすぎないように注意する。
  - ビジネス要件に焦点を当てる。
- **独立性の確保**:
  - 各シナリオは他のシナリオの実行結果に依存せず、単独で実行可能であるべき。
  - 必要なデータや状態は、そのシナリオ内(または Background)で完結するように設定する。
- **単一責任**: 一つのシナリオでは、検証したい振る舞いを一つに絞り込む。
- **ステップの再利用**:
  - 共通の前提条件 (`Given`)、操作 (`When`)、検証 (`Then`) は、パラメータ化された**ステップ定義**として実装し、再利用を促進する(コード圧縮)。Background だけでなく、個別のシナリオ内でもこれらの共通ステップ定義を呼び出すことが重要。
## 3. Scenario Outline と Examples
- **目的**: 同じ振る舞いを異なるデータパターンでテストしたい場合に使用する。
- **パラメータ**: `Examples` テーブル内のパラメータ名と値は、**半角英数字** および **スネークケース** で必ず記述する。これはテストの安定性向上、文字化けリスク回避、CI 環境等での互換性確保のため。
- **コメント**: ステップ定義に `#` で始まるコメントをつけるとバグが発生するので、コメントは使用せず。ステップ定義を具体的な説明に変更する。
- **類似ケース**: 類似のケースを複数テストする場合はシナリオアウトラインを使用する。
## 自己チェック義務
AI は `.feature` ファイルを生成･編集した後、ユーザーに提示する前に**必ず**以下の点について自己チェックを行い、ルール違反があれば修正すること。
- [ ] **半角文字:** 全角英数字･全角記号が含まれていないか? (特に括弧、スペース)
- [ ] **テーブル:** `datatable` や `Examples` の中で全角文字を使用していないか?

# BDD ステップ定義 ガイドライン (AI向け指示)
## 1. ステップ定義の基本原則
### 1.1 再利用性と明確性
- **配置**: テストの種類(単体/統合)に応じて、定められたディレクトリ (`tests/step_defs` または `tests/integration`) にステップ定義を配置する。
- **紐付け**: Feature ファイルとステップ定義は、`scenarios` 関数などを用いて適切に関連付けること。テスト関数内での `@scenario` デコレータの使用はしない。
- **パラメータ化**: 同一ロジックを異なるシナリオで再利用できるよう、ステップ定義は積極的にパラメータ化すること。適切なパーサー機能 (`parsers.parse` など) を活用して、Feature ファイルからの値を受け取れるように設計すること。
- **命名規則**:
    - ステップ定義関数には、その役割 (Given/When/Then) を示すプレフィックス (`given_`, `when_`, `then_`) を付与し、目的を明確にすること。
    - Feature ファイルのステップ記述と、対応するステップ定義関数の命名には一貫性を持たせること。
- **関数の序列**: 役割 (Given/When/Then) のごとにまとめる。
- **値の受け渡し**: あるステップで生成した値を後続のステップで利用する場合は、`target_fixture` のようなフィクスチャ渡し機能を利用して、明確に値を引き渡すこと。
- **datatabele**: feature ファイルで定義されたテーブルはpytest-bddがデフォルトで提供する `datatabele` フィクスチャで参照する。
### 1.2 依存関係とセットアップ
- **フィクスチャの活用**: テスト実行前のセットアップ(DB接続、テストデータ準備など)、共通データの提供、テスト後のクリーンアップ処理は、pytest の標準的なフィクスチャ機能 (`@pytest.fixture`) を用いて実装すること。
- **依存性の明示**: ステップ定義が必要とするデータや事前状態は、フィクスチャを引数として受け取ることで、依存関係をコード上で明確に示すこと。
- **自動実行**: 全テストで共通して必要なセットアップやクリーンアップ(一時ファイルの管理など)は、自動実行されるフィクスチャ (`autouse=True` を指定) の利用を検討すること。
- **BDD専用ヘルパー**: BDD シナリオに特有のセットアップやヘルパー関数が必要な場合は、専用のフィクスチャとして整理し、再利用性を高めること。
## 2. ステップ定義の構成と責務
### 2.1 モジュール性と整理
- **共通化**: プロジェクト全体や特定の機能群で共通して利用できる**フィクスチャやヘルパー関数**は、`conftest.py` に定義するか、専用のヘルパーモジュールに集約し、インポートして利用すること。共通の**ステップ定義**自体は、関連性の高いステップ定義ファイルに含めるか、必要に応じて専用のステップ定義モジュールを作成すること。
- **責務分離**: ステップ定義ファイルは、関連する機能やドメインごとに分割し、各ファイルが持つ責務を明確に保つこと。
### 2.2 適切な粒度
- **単一アクション/検証**: 一つのステップ定義は、原則として一つの具体的なアクション(When)または検証(Then)に対応するように、適切な粒度で設計すること。複雑な処理は複数のステップに分割するか、ヘルパー関数に切り出すことを検討すること。
## 3. 実装上の考慮事項
- **状態管理**: ステップ間で状態を共有する必要がある場合は、フィクスチャ (`target_fixture` や共有コンテキストオブジェクト) を介して行うこと。グローバル変数の使用は避けること。
- **アサーションの配置**:
    - `Then` ステップには、期待される結果を検証するための明確なアサーションを含めること。
    - `When` ステップはアクションの実行に集中し、原則としてアサーションを含めないこと。
- **可読性**: 関数名、変数名、コメントを適切に用い、ステップ定義コード自体の可読性を高く保つこと。処理の意図が明確に伝わるように記述すること。
- **ドキュメンテーション連携**: ステップ定義は、対応する Feature ファイル(エンドユーザー視点のドキュメント)と連携して理解されるものであることを意識すること。

# テスト (常に実装後にテストを書く) [ACT/Codeモード]
<TESTING>
<DEPENDENCY BASED TESTING>
新しい機能には必ずユニットテストを書く。<ANALYZE CODE>で確認した影響範囲すべてについてテストを実施する。
</DEPENDENCY BASED TESTING>
<NO BREAKAGE ASSERTION>
変更提案後、必ず自分でテストを実行し、パスを確認する。他人任せにせず、コードが壊れていないことを確実にする。
</NO BREAKAGE ASSERTION>
1. テストロジックは実装コードとは別ファイルに書く。クリーンで保守性の高いコードを保つため。
<TEST PLAN>
- 要件や期待される結果に対して、十分網羅的なテスト計画を立てる。
- エッジケースも含めた包括的なテストシナリオを設計する。
- プロジェクトの技術スタックに応じた検証方法を定義する。
- ソリューションの効果を確認するためのモニタリング方法も提案する。
- リグレッション(既存機能の劣化)防止も考慮する。
</TEST PLAN>
2. 重要な新機能には**必ず**テストコードを書く。まず<DEPENDENCY BASED TESTING>と<NO BREAKAGE ASSERTION>で基礎テスト、その後<TEST PLAN>に基づき拡張テストを書く。
3. テスト記録は@memory.mdcに従って整理する。
</TESTING>

- 新機能の実装時には、細部まで徹底して実装･テストを行い、**テスト完了まで決して途中で止めないこと**。

---
コード実装や変更後には**必ず**2つのことを行う:
a. `src` やその他コード内で影響する可能性のある箇所も更新する。
b. `docs/` と `tasks/` のドキュメントを更新する。
