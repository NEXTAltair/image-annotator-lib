---
description: captures important patterns, preferences, and project intelligence, living document that grows smarter as progress happens
globs: 
alwaysApply: false
---
---
description: Stores important patterns, preferences, and project intelligence, living document that grows smarter as progress happens
globs:
alwaysApply: true
---

# Lessons Learned & Project History

## プロジェクト初期 (2023-10-27頃)

- **初期ドキュメント:** プロジェクト開始時、`memory-bank` ディレクトリ内にプロジェクトコンテキスト、進捗、決定ログを記録する方針決定。一貫情報追跡と後開発支援目的。
- **決定ログ形式:** 日付、決定内容、理由、代替案、影響記録形式採用。
- **初期マイルストーン:** プロジェクトセットアップ(構造定義、memory-bank初期化、環境設定、バージョン管理)→ コアライブラリ実装 → 初期機能セット、段階的開発計画立案。

## ドキュメント整理経緯

- **統合計画 (日付不明):** リファクタリング後ドキュメント更新計画立案。既存構造把握、リファクタリング詳細確認、更新計画作成、実施、確認、完了ステップ定義。
- **削減計画 (2025-04-18):** ドキュメントファイル数多すぎ (11ファイル) フィードバック受け、約7ファイルへ削減計画立案。必須ドキュメント維持しつつ、解説・設計関連ドキュメントを `docs/EXPLANATION/integrated_architecture.md` (当時) に統合、不要ファイル削除方針決定。
- **現状整理 (2025-04-29~):** 設定ドキュメント (V2: Updates) 基盤、`memory-bank` 内容を推奨メモリファイル (`docs/product_requirement_docs.md`, `docs/architecture.md`, `docs/technical.md`, `tasks/tasks_plan.md`, `tasks/active_context.md`, `.cursor/rules/lessons-learned.mdc`, `.cursor/rules/error-documentation.mdc`) へ移行・統合中。

## 主要完了済作業 (過去記録より)

- **設計アウトライン定義:** 統合ライブラリ基本構造、クラス階層、主要コンポーネント方針定義。
- **コアモジュール実装:** `BaseAnnotator`, フレームワーク別基底クラス, `ModelLoad`, `ModelRegistry`, 設定/ユーティリティ関数, カスタム例外, `annotate` API 関数実装。
- **モデルクラス移植:** 各種 Tagger/Scorer モデルクラスを新クラス階層適合。
- **コードリネーム:** API 関数名 (`evaluate`->`annotate`), 設定ファイル名 (`models.toml`->`annotator_config.toml`) 変更。
- **ドキュメント整理 (Diátaxis):** `docs/` ディレクトリを Diátaxis フレームワーク基盤整理・統合 (当時)。
- **Memory Bank 更新 (当時):** 開発中情報を `memory-bank` 内各ファイル記録。

## 主要技術決定 (詳細は architecture.md, technical.md 参照)

- ログ出力多重化問題修正 (2025-04-19)
- レジストリ・logger初期化明示化 (2025-04-19)
- CUDA非対応環境CPUフォールバック実装 (2025-04-19)
- 全モデルローダーへ早期サイズ計算・メモリ管理強化 (2025-04-20頃)
- ModelConfigRegistry システム/ユーザー設定分離 (2025-04-20頃)
- CLIPLoader リファクタリング (2025-04-20頃)
- ModelLoad 状態変数カプセル化 (2025-04-21頃)
- `annotator_config.toml` キー設計維持決定 (2024-07-28)
- Web API アノテーター初期化フロー変更 (2024-07-28)
- **API利用モデル動的取得機能実装 (日付不明):**
    - `annotator_config.toml` ハードコーディングAPIモデル名を、OpenRouter API等から動的取得・更新機能 (`core/api_model_discovery.py`) 実装。
    - 取得情報は `config/available_api_models.toml` にキャッシュ・永続化。

## 旧ライブラリ情報 (統合元)

現状 `image-annotator-lib` は、旧ライブラリ `scorer_wrapper_lib` と `tagger_wrapper_lib` 統合版。

- **概要:** 統合前、画像スコアリング機能と画像タギング機能は各々独立ライブラリ開発。
- **基本アーキテクチャ共通点:** 両ライブラリ共、基底クラス、モデルタイプ別中間クラス、具象モデルクラス、設定ファイル、レジストリ、主要 API 関数 (`evaluate` 関数等)、モデル管理といった共通設計要素保有。ただし実装詳細・命名規則差異あり。
- **統合経緯:** 機能的重複多く、特にモデル管理・コア基底クラス設計で共通化メリット大と判断され、単一ライブラリへ統合実施。API 統一で利用者両機能シームレス扱えるようにすることも目的。

## リファレンス実装経緯

本ライブラリは、`scorer_wrapper_lib` と `tagger_wrapper_lib` 統合・改良で作成。複数主要変更点は以下。

1.  **クラス階層最適化**: 以前個別モデルクラスで相当重複あったコードを、基底クラス集約。
2.  **結果形式統一**: 異形式だった Tagger/Scorer 結果を統一フォーマット返却変更。
3.  **メモリ管理改善**: より洗練モデルキャッシュ戦略実装。

4.  **エラーハンドリング強化**: より詳細・一貫エラー報告導入。

# pytest-bdd: Scenario Outlineで日本語+<param>記法の既知問題

## 概要
- Scenario Outlineで日本語ステップと<param>(例: <cache_state>)を組み合わせると、pytest-bddが<param>部分を正しくパースできず、step定義がマッチしないことがある。

## 詳細
- 英語では正常動作するが、日本語やマルチバイト文字列では<param>の展開・マッチングが不安定。
- 公式issueや日本語コミュニティでも同様の報告多数。
- pytest-bddのバージョンアップで解消される可能性もあるが、現状は「日本語+<param>」は非推奨。

## 対応方針
- 今後この警告・エラーは既知の仕様制約として**無視**する。
- 必要なら英語に置き換える、または具体値で全列挙・正規表現stepで回避する。

## 参考
- 公式issue: pytest-bddで日本語+パラメータ化が動作しない事例あり
- Qiita等: pytest-bddで日本語ステップが動かない報告あり

## [2025-05-04] BDDステップ定義ファイルとBDDテストファイルの違い

- **BDDテストファイル(シナリオ本体)**
    - `.feature`ファイル、またはpytest-bdd等で`scenarios()`を呼び出すPythonファイル。
    - テストの「流れ」や「振る舞い」(Given/When/Thenで表現されるシナリオ)を記述する。
    - 例: `tests/features/annotate.feature`、`tests/integration/test_tagger_integration.py` など。
    - これが「何をテストしたいか」を記述する部分。

- **BDDステップ定義ファイル**
    - 各シナリオの「Given/When/Then」文に対応するPython関数(@given/@when/@thenデコレータ付き)を実装するファイル。
    - 例: `tests/features/step_definitions/annotate_steps.py` など。
    - これが「どうやってテストを実行するか」(各ステップの具体的な処理)を記述する部分。

- **違いまとめ**
    - テストファイル(シナリオ本体)は「テストの流れ・仕様」を記述。
    - ステップ定義ファイルは「各ステップの実装(Python関数)」を記述。
    - 両者が揃って初めてBDDテストが成立する。

- **教訓:**
    - BDDでは「シナリオ本体(featureやscenarios())」と「ステップ定義(Python関数)」を明確に分離・管理することが重要。
    - どちらか一方だけではテストは動作しない。

## [2025-05-04] ステップ定義ファイルの命名規則について

- **結論:**
    - ステップ定義ファイル(step_definitions配下)は`test_`で始める必要はない。
    - むしろ`test_`で始めない方が、テスト本体(統合テストやユニットテスト)と明確に区別でき、混乱が少ない。

- **理由:**
    - pytestやpytest-bddは、@given/@when/@thenデコレータ付き関数を含むファイルであれば、ファイル名に制約はない。
    - `test_`で始めるとpytestの通常のテスト検出ルール(python_files = test_*.py等)により、テスト本体と誤認されて二重実行や混乱の原因になることがある。
    - プロジェクトの可読性・保守性向上のため、`annotate_steps.py`や`common_steps.py`のような命名が推奨される。

- **教訓:**
    - ステップ定義ファイルは`test_`で始めない命名規則を徹底する。
    - テスト本体とステップ定義を明確に分離・管理することで、開発効率と品質が向上する。

## [2025-07-31] pytest-bdd: Feature, Step Definition, Test Runner の分離

- **結論:** BDDテストにおいて、以下の3つの要素を明確に分離することが推奨される。
    1.  **Feature ファイル (`.feature`):** テストシナリオ(振る舞い)を自然言語で記述。「何を」テストするかを定義。
    2.  **ステップ定義ファイル (`*_steps.py`):** Feature ファイル内の各ステップ(Given/When/Then)に対応する Python コードを実装。「どのように」テストを実行するかを定義。
    3.  **テストランナーファイル (`test_*.py`):** `pytest-bdd` の `scenarios()` を呼び出し、対象の Feature ファイルとステップ定義ファイルを紐づけてテストを実行する。
- **利点:**
    - **関心の分離:** 各ファイルの役割が明確になり、理解と変更が容易になる。
    - **可読性と保守性:** 仕様(.feature)と実装(_steps.py)が分離され、メンテナンス性が向上する。
    - **再利用性:** ステップ定義を複数の Feature ファイルで再利用しやすくなる。
    - **コラボレーション:** 非開発者も Feature ファイルのレビューに参加しやすくなる。
    - **ツール親和性:** `pytest-bdd` や `pytest` の標準的な仕組みと整合性が取れ、予期せぬ動作を防ぐ。
- **実装方針:**
    - ステップ定義ファイル (`*_steps.py`) には `scenarios()` を記述しない。
    - `tests/` 配下に `test_bdd_runner.py` のような専用のテストランナーファイルを配置し、そこから必要なステップ定義ファイルをインポートして `scenarios('features/')` を呼び出す。
    - `pyproject.toml` の `python_files` は `["test_*.py"]` のように、テストランナーファイルのみを対象とする。

## [2025-08-05] タスク整理に関する教訓

- 大量のタスクリストは可読性を損ない、重複や優先度の混乱を招く。定期的な "サマリー" セクションの挿入で全体像を把握しやすくする。
- アクティブタスクとアーカイブ済みログを明確に分離すると、日常の開発サイクルで必要な情報抽出が迅速になる。
- `tests/` や `src/` の最新状態を確認した上でタスクを整理することで、現実と計画のギャップを最小化できる。
- ドキュメント更新もタスクの一部と捉え、コード変更と同じレビュープロセスに含めると漏れが減少する。

## テスト戦略に関する教訓

### [2025-05-08] pytest-bdd: データテーブルのステップ間引き継ぎ

- **問題点:** `pytest-bdd` の通常の `Scenario` では、`Given` ステップで定義されたデータテーブルを、後続の `Then` ステップで直接 `datatable` 引数として受け取ることができない場合がある (エラー `fixture 'datatable' not found` が発生する)。
- **解決策:** `Given` ステップのデコレータに `target_fixture="任意のフィクスチャ名"` を追加し、ステップ関数内でデータテーブルを `return` する。後続の `Then` ステップでは、`datatable` 引数の代わりに、指定した「任意のフィクスチャ名」を引数として受け取ることで、データテーブルの内容を引き継ぐことができる。
- **教訓:** ステップ間でデータテーブルの内容を共有したい場合は、`target_fixture` を活用する。

### [2025-05-07] モデルレジストリのBDDテストにおける設定ファイルの扱い

- **初期アプローチと課題:**
    - `tests/features/registry.feature` のテストにおいて、当初はテストの独立性と再現性を高めるため、モデル設定 (`annotator_config.toml`) をモック化する方針を検討した。
    - しかし、ライブラリの `__init__.py` がインポート時にレジストリを初期化する挙動と、BDDステップの実行タイミングの兼ね合いから、モック設定を確実に適用するためのテストコード(特にフィクスチャやパッチ処理)が複雑化する傾向が見られた。
- **方針転換と理由:**
    - テストコードの可読性とメンテナンス性、および実環境との整合性を総合的に考慮し、設定ファイルのモック化は行わず、原則として実際の `annotator_config.toml` を直接読み込んでテストする方針に転換した。
    - これにより、テストは実際の設定ファイルの内容に依存することになるが、レジストリ機能が実設定と正しく連携するかの検証精度が向上し、テストコードの記述も簡潔になるメリットを優先した。
- **教訓:**
    - テストの理想(完全な独立性、再現性)と、現実的な実装コスト(コードの複雑さ、メンテナンス性)のバランスを考慮する必要がある。
    - ライブラリの初期化処理のような、テスト対象の外部にある要因がテストの設計に大きく影響する場合があることを認識し、場合によってはテスト戦略そのものを見直す柔軟性も重要。
    - 設定ファイルにテスト用の不正なデータ(例: クラス名のないモデル定義)が存在すると、初期化処理で警告が発生し、後続のテスト(特にモデル数を検証するようなケース)が意図せず失敗することがあるため、設定ファイル自体の健全性も重要。

### [2025-05-07] BDDテストにおけるアサーションとデータ構造の整合性

- **型の不一致への対応:**
    - テストコードにおける型アサーション (`isinstance` 等) は、ライブラリ内部で実際に使用される具体的なデータ型を正確に反映する必要がある。
    - 特に数値型の場合、Python標準の `float` だけでなく、NumPyの `np.float64` やその基底クラスである `np.floating` など、関連する型も比較対象に含める検討が重要 (例: `isinstance(value, (float, np.floating))`)。
- **テストの期待値とAPI設計の調和:**
    - テストケースが期待するデータ構造と、実際のAPIが返すデータ構造との間に不整合が見つかった場合、どちらを修正すべきか慎重に判断する必要がある。
    - APIの設計思想(例: 返り値のシンプルさ、責務の範囲)と、テストの目的(例: 検証の網羅性、コードの堅牢性)を天秤にかけ、よりプロジェクト全体の品質向上に資する選択をすべき。
    - 例えば、テストがAPIの返り値に特定のメタ情報 (`meta`キーなど) を期待していたが、API設計上それが冗長であると判断した場合、APIを変更するのではなくテスト側の検証ロジックを修正する(または別の方法で間接的に検証する)方が適切な場合がある。
- **アサーションメッセージの具体性:**
    - `AssertionError` のメッセージは、デバッグ効率を大幅に向上させるため、可能な限り具体的な情報を含めるべきである。
    - 何が期待され (Expected)、実際に何であったか (Actual) を明確に示すことで、問題箇所の特定が迅速になる (例: `f"Expected: {expected_value}, Actual: {actual_value} for variable HOGE"`)。
    - 型チェックの場合は、期待した型と実際の型、さらには問題となっている変数の名前や値をメッセージに含めると非常に有効 (例: `f"Tag: {tag} (type {type(tag)}), Conf: {conf} (type {type(conf)}) - Expected str and float/np.floating."`)

## コーディング規約と自動化

## Web API クライアントライブラリの変更対応と型定義の教訓 (2025-08-05頃)

`annotator_webapi.py` において、複数の外部APIクライアント (Google Gemini, OpenAI, Anthropic) のSDK更新や、それに伴う型定義の修正、Linterエラーの解消に多くの時間を費やした。

-   **SDKの追従と破壊的変更:**
    -   Google Gemini API: `google.genai` SDKの利用において、API呼び出し方法、応答オブジェクトの構造、特に `Part` オブジェクトの作成方法などに変更があり、ドキュメントの精読と試行錯誤が必要だった。`response_schema` を利用したJSON出力の扱いや、エラーハンドリングも注意が必要。
    -   OpenAI API: `openai` ライブラリ v1.x 系への移行に伴い、型定義のインポート元 (`openai.types.chat` など) や `NOT_GIVEN` の扱いが変更された。Linter (Pyright/Pylance) がこれらの新しい型を正しく認識しない場合があり、インポート方法の工夫や、Linter側の問題である可能性の切り分けが必要だった。
    -   Anthropic API: `NOT_GIVEN` のインポート元 (`anthropic._types`) の特定や、JSONモード出力のためのTool Useの利用方法など、SDK固有のテクニックが必要だった。
-   **型定義の複雑さ:**
    -   複数のAPI応答を統一的に扱うための `Responsedict` や `FormattedOutput` といった `TypedDict` の型定義は、各APIクライアントの応答型 (`GenerateContentResponse`, `ChatCompletion`, `Message`) のUnion型となり、複雑化しやすい。
    -   特にLinterがUnion型内の特定の型を推論しきれず、属性アクセスエラーを誤検知するケースが見られた。これに対し、`isinstance` で型ガードを行う、`cast` を使う（最終手段）、あるいはLinterの設定を見直すなどの対応が考えられる。今回は主に型ガードで対応。
-   **`NOT_GIVEN` の扱い:**
    -   OpenAI と Anthropic で `NOT_GIVEN` (またはそれに類する定数) のインポート元や扱い方が異なり、それぞれ個別に対応が必要だった。型ヒントで `Literal[NOT_GIVEN]` のように指定する必要がある場合もあった。
-   **Linter との連携:**
    -   Linter (Pyright/Pylance) の型チェックは非常に有用だが、新しいライブラリや複雑な型定義に対しては、時として過剰なエラーを報告したり、正しいコードを誤ってエラーと判断したりすることがある。
    -   エラーメッセージを鵜呑みにせず、ライブラリの公式ドキュメントや実際の動作を確認し、Linter側の問題なのか、コード側の問題なのかを慎重に切り分ける必要がある。
-   **ドキュメントの重要性:**
    -   外部ライブラリの変更に追従する際は、公式ドキュメントのリリースノートや移行ガイドを熟読することが不可欠。特にメジャーバージョンアップ時は、破壊的変更が含まれることが多い。
-   **テストを通すための修正の意義:**
    -   `annotator_webapi.py` の変更は、Linterエラーを解消しコードの静的解析をパスさせることが主な目的の一つだった。これにより、実行前に型の不整合や潜在的なバグを発見しやすくなり、コードの信頼性が向上する。
    -   信頼性の高いコードは、テストの安定性を高め、予期せぬ型エラーなどによるテスト失敗を防ぐ。結果として、BDDテストスイート全体の安定稼働と、仕様通りの動作保証に繋がる。

## [2025-08-06] Google Gemini API対応・テスト設計・設計原則の知見

- Google Gemini API (google-genai) のバージョン差異・破壊的変更に注意。旧SDK (google-generativeai) の知識で実装しない。
- SDKアップグレードで "空文字・パース不能" 問題が解消する場合あり。破壊的変更時は型・レスポンス構造・エラーハンドリングの見直し必須。
- エラーハンドリングは google.genai が返す例外のみcatch。他パッケージ (google.api_core等) の例外は不要。
- APIレスポンスのパース不能・空文字の主因はプロンプト設計不備・モデル制約・API仕様変更。まずプロンプト設計・タスク設計を見直すこと。
- テストコードは「設計・責務」を正しく理解した上で書く。annotator_clsは初期化時に論理名(model_name_short)を渡す設計。APIモデルIDではない。
- with文で使う設計だが、初期化時の引数は論理名。テストで設計無視の引数や使い方は厳禁。
- BDDテストはFeature/ステップ定義/テストランナーを明確に分離。ステップ定義ファイルはtest_で始めない。日本語+<param>のScenario Outlineはpytest-bddの既知バグあり（無視または英語化）。
- 設定ファイルの内容がconfig_registryに反映されていない場合、config_registry.load()を明示的に呼ぶ。
- 重大なエラー・設計判断はlessons-learned.mdcやerror-documentation.mdcに記録。

## [2025-05-10] BDDテストにおけるモック戦略の改善（`ModelLoad` の選択的モック）

- **問題点:**
    - 当初、`conftest.py` で定義された `ModelLoad` のモック (`mock_model_load_instance` フィクスチャ) が、意図せず広範囲のテストシナリオに適用されていました。
    - これにより、`@base.feature` や `@model_factory.feature` のようなユニットテストに近いフィーチャーはモックによってパスしていましたが、実コンポーネントの動作検証を主目的とする `@annotation_scorer.feature` のテストが、実物の `ModelLoad` を使用できず失敗していました。

- **解決策:**
    1. `mock_model_load_instance` フィクスチャの `autouse` 設定を `False` にする（または、そうなっていることを確認）。これにより、フィクスチャが自動的に全テストに適用されるのを防ぎます。
    2. テストシナリオごとにモックの適用を選択できるように、以下の2つのBDD `Given` ステップを `tests/features/step_definitions/annotation_steps.py` に定義・活用します:
        - `Given テストにはモックやダミーを使用しない`: このステップが記述されたシナリオでは、`mock_model_load_instance` フィクスチャは注入されず、実コンポーネントが使用されます。
        - `Given このテストではモデルインスタンスのモックを使用する`: このステップが記述されたシナリオでは、`mock_model_load_instance` フィクスチャが（pytestのフィクスチャ解決機構を通じて）注入され、`ModelLoad` がモックされます。
    3. 各フィーチャーファイル (`.feature`) の `Background` または個別の `Scenario` に、上記の適切なステップを記述することで、テストの振る舞いを明確に制御します。
        - 例: `@base.feature` や `@model_factory.feature` の `Background` には `Given このテストではモデルインスタンスのモックを使用する` を追加。
        - 例: `@annotation_scorer.feature` の `Background` には、既に記述されている `Given テストにはモックやダミーを使用しない` を維持。

- **教訓:**
    - BDDテストにおいて、モックの使用はテスト対象の性質やシナリオの意図に応じて柔軟に、かつ明示的に制御できるべきです。
    - 広範囲すぎる、あるいは暗黙的なモックの適用は、特定のテストシナリオ（特に統合テストや実コンポーネントの動作検証を目的とするもの）で予期せぬ問題を引き起こす可能性があります。
    - `Given` ステップを通じてモックの有無を宣言するアプローチは、テストの前提条件を明確にし、可読性と保守性を向上させます。

# 【修正後追記】
## [2025-05-10] BDDテストのモック利用方針の抜本的変更
- BDDテストは統合テストとして実施し、原則としてモック・ダミー・スタブ等は使用しない。
- すべての主要コンポーネント・外部依存を実際に動作させ、システム全体の振る舞いを検証する。
- モックが必要な場合は、ユニットテストまたは明示的な例外ケースに限定する。